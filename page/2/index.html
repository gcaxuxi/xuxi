<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Absolute Zero</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Zerum est cunctum">
<meta property="og:type" content="website">
<meta property="og:title" content="Absolute Zero">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Absolute Zero">
<meta property="og:description" content="Zerum est cunctum">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Absolute Zero">
<meta name="twitter:description" content="Zerum est cunctum">
  
    <link rel="alternative" href="/atom.xml" title="Absolute Zero" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!-- Google Analytics -->
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-51165937-2', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/images/cat.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">xuehy</a></h1>
		</hgroup>

		
		<p class="header-subtitle">The Garden of Zeros</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>標籤</li>
						
						
						<li>關於</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/categories/old">过去的旧文章</a></li>
				        
							<li><a href="/categories/computervision">计算机视觉</a></li>
				        
							<li><a href="/categories/passages">随笔</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/vision/" style="font-size: 10px;">vision</a> <a href="/tags/技术/" style="font-size: 10px;">技术</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">Cogito ergo sum</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">xuehy</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/images/cat.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">xuehy</h1>
			</hgroup>
			
			<p class="header-subtitle">The Garden of Zeros</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/categories/old">过去的旧文章</a></li>
		        
					<li><a href="/categories/computervision">计算机视觉</a></li>
		        
					<li><a href="/categories/passages">随笔</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-2015-08-01-convex_sets" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/02/2015-08-01-convex_sets/" class="article-date">
  	<time datetime="2015-08-02T13:40:58.000Z" itemprop="datePublished">2015-08-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/02/2015-08-01-convex_sets/">Convex Sets and Convex Sets Algebra</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###概念<br>前面我们已经知道仿射集$A$是这样的元素的集合：</p>
<p>$$<br>\lambda x + (1- \lambda) y \in A,\; \forall \lambda\in R, \forall x,y\in A<br>$$</p>
<p>如果我们限定</p>
<p>$$<br>\lambda \in [0,1]<br>$$</p>
<p>则得到了一个仿射集的子集$C$，这样的集合称为凸集。对应到二维的图像上看，凸集中任意两点的连线段一定完全在该集合之内。</p>
<p>显然仿射集比凸集更加严格。</p>
<p>###凸包<br>任意的凸集交在一起仍然是凸集。任意给定$S\subset R^n$，$S$的凸包$\mathrm{conv} S$是包含$S$的最小的凸集。</p>
<p>有限多个点的凸包叫做多胞形(polytope)。</p>
<p>若</p>
<p>$$<br>b_0,b_1,\cdots,b_m<br>$$</p>
<p>是仿射无关的，它的凸包称为$m$维单纯形。</p>
<p>###凸集的维度<br>给定凸集$C$，</p>
<p>$$<br>\mathrm{dim}\;C = \max_{S_i\subset C,\;S_i \text{ is a simplex}} \mathrm{dim}\;S_i<br>$$</p>
<p>###锥</p>
<p>一个集合$K\subset R^n$称为锥，如果它对于正数标量乘法是封闭的，即</p>
<p>$$<br>\lambda x\in K,\; \forall x\in K, \lambda &gt; 0<br>$$</p>
<p>凸锥定义为满足凸集条件的锥。</p>
<p>任意的凸锥的交集也是凸锥。</p>
<p>一个集合是凸锥当且仅当它对于加法和正标量乘法封闭。</p>
<p>###法线</p>
<p>给定一个凸集$C$，在点$a\in C$处，向量$x^*$称为在$a$处normal于$C$的，若</p>
<p>$$<br>\langle x-a,x^* \rangle \le 0,\; \forall x\in C<br>$$</p>
<p>所有的法线构成的集合称为$C$在$a$处的normal cone。</p>
<p>###凸集代数</p>
<ul>
<li>若$C_1,C_2$为$R^n$中的凸集，则</li>
</ul>
<p>$$<br>C_1+C_2=[x_1+x_2|x_1\in C_1,x_2\in C_2]<br>$$</p>
<p>也是凸集。</p>
<ul>
<li>若$C$是凸集，$\lambda_1 \ge 0$， $\lambda_2 \ge 0$，则</li>
</ul>
<p>$$<br>(\lambda_1 + \lambda_2)C = \lambda_1 C + \lambda_2 C<br>$$</p>
<ul>
<li>令</li>
</ul>
<p>$$<br>[C_i|i\in I]<br>$$</p>
<p>为$R^n$中任意的非空凸集的一个集合。</p>
<p>将这些集合并集的凸包记作$C$，则</p>
<p>$$<br>C = \mathrm{conv}\; \bigcup_i C<em>i = \bigcup \sum</em>{i\in I}\lambda_i C_i<br>$$</p>
<ul>
<li><p>线性变换保持凸集的凸性不变</p>
</li>
<li><p>若$C$和$D$分别是$R^m$和$R^p$中的凸集，则</p>
</li>
</ul>
<p>$$<br>C \oplus D = [x=(y,z)|y\in C, z\in D]<br>$$</p>
<p>为$R^{m+p}$里的凸集</p>
<ul>
<li>令$C_1$和$C_2$为$R^{m+p}$中的凸集，令$C$为这样的向量的集合，$x=(y,x)$，$y\in R^m$且$z\in R^p$，满足：</li>
</ul>
<p>$$<br>\exists z_1z_2, (y,z_1)\in C_1,(y,z_2)\in C_2,z_1+z_2 = z<br>$$</p>
<p>则$C$也为凸集。</p>
<ul>
<li>若$C_1$和$C_2$是$R^n$中的凸集，那么它们的inverse sum，</li>
</ul>
<p>$$<br>C_1 # C_2 = \bigcup [\lambda_1 C_1 \cap \lambda_2 C_2|\lambda_i \ge 0,\lambda_1 + \lambda_2 = 1]<br>$$</p>
<p>也是凸集。</p>
<h3 id="Umbra"><a href="#Umbra" class="headerlink" title="Umbra"></a>Umbra</h3><ul>
<li>$C$关于$S$的阴影（umbra），</li>
</ul>
<p>$$<br>\bigcap<em>{x\in S}\bigcup</em>{\lambda \ge 1}[(1-\lambda)x+\lambda C]<br>$$</p>
<ul>
<li>$C$关于$S$的半影（penumbra），</li>
</ul>
<p>$$<br>\bigcup<em>{x\in S}\bigcup</em>{\lambda \ge 1}[(1-\lambda)x+\lambda C]<br>$$</p>
<ul>
<li>$C$凸 $\Rightarrow$ umbra也为凸</li>
<li>$C$和$S$都为凸，则penumbra凸</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/old/">old</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









<!-- 多说评论框 start -->
     <div class="ds-thread" data-thread-key="2015/08/02/2015-08-01-convex_sets/" data-title="Convex Sets and Convex Sets Algebra" data-url="http://yoursite.com/2015/08/02/2015-08-01-convex_sets/"></div>
     <!-- 多说评论框 end -->
     <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
     <script type="text/javascript">
     var duoshuoQuery = {short_name:"hyxue-zeros"};
     	 (function() {
			var ds = document.createElement('script');
			       ds.type = 'text/javascript';ds.async = true;
			       	       	 ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					 	  ds.charset = 'UTF-8';
						  	       (document.getElementsByTagName('head')[0]
									 || document.getElementsByTagName('body')[0]).appendChild(ds);
									    })();
										</script>
										<!-- 多说公共JS代码 end -->
										
  
    <article id="post-2015-07-29-affine_sets" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/28/2015-07-29-affine_sets/" class="article-date">
  	<time datetime="2015-07-28T13:40:58.000Z" itemprop="datePublished">2015-07-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/28/2015-07-29-affine_sets/">Affine sets</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这一段时间打算好好把Rockafellar的《凸分析》一书看一遍，说来惭愧，这本书在我手里已经快两年了，但是只看过前几章。接下来打算趁着这一段空闲时光看完它，然后顺便在这里做点笔记。</p>
<h2 id="1-_u4EFF_u5C04_u96C6_u5408"><a href="#1-_u4EFF_u5C04_u96C6_u5408" class="headerlink" title="1.仿射集合"></a>1.仿射集合</h2><p>首先$\mathbb{R}^n$代表一般的$n$维向量空间，所谓的<em>仿射集合</em>或者叫<em>仿射流形</em>指的是满足以下条件的点构成的集合：</p>
<p>$$<br>[(1-\lambda)x + \lambda y, \; \lambda\in \mathbb{R},\; x,y\in\mathbb{R}^n,\; x\ne y]<br>$$</p>
<p>其中$x,y$是给定的两个点。</p>
<p>直觉上来讲<em>仿射集合</em>就是通过给定两个点的一个超直线。显然空集和$\mathbb{R}^n$本身都是仿射集合的特例。</p>
<p>仿射集合和线性子空间看起来有一些类似之处，接下来的一些定理是有关仿射集合和线性子空间之间关系的。</p>
<ul>
<li>TH1. $<br>\mathbb{R}^n$的子空间都是包含原点的仿射集合。</li>
</ul>
<ul>
<li>然后关于仿射集合有一个<em>平行</em>的概念，所谓仿射集合$M$和$L$平行，指的是存在$a$使得$M=L+a$。</li>
</ul>
<ul>
<li>TH2. 每一个非空仿射集合$M$都平行于唯一的一个子空间$L$，其中<br>$$<br>L = M - M = [x-y|x\in M,y\in M]<br>$$</li>
</ul>
<ul>
<li>非空仿射集合的<em>维度</em>定义为其平行子空间的维度。</li>
<li>$\mathbb{R}^n$中$(n-1)$维的仿射集合称为<em>超平面</em>.</li>
</ul>
<ul>
<li>TH3. 给定$\beta\in R$和一个非零点$b\in \mathbb{R}^n$，<br>$$<br>H = [x|\langle x,b \rangle=\beta]<br>$$<br>为一个超平面</li>
<li>TH4.给定$b\in \mathbb{R}^m$, $B \in \mathbb{R}^{m\times n}$。<br>$$<br>M = [x\in \mathbb{R}^n|Bx = b]<br>$$<br>是$\mathbb{R}^n$中的一个仿射集。反过来，每一个仿射集都可以表示成这样的形式。</li>
<li>仿射包。任意给定一个$S \subset \mathbb{R}^n$，存在一个唯一的最小仿射集包含$S$，这个仿射集就叫做$S$的仿射包，记作$\mathrm{aff}\;S$。</li>
<li><p>$m+1$个点$b_0,b_1,\cdots,b_m$称为是<em>仿射无关</em>的，如果$\mathrm{aff}\;{b_0,b_1,\cdots,b_m}$是$m$维的。</p>
</li>
<li><p>每一个$m$维仿射集合都可以表示为$m+1$个点的仿射包。</p>
</li>
<li><p>仿射变换：$T:\mathbb{R}^n\rightarrow \mathbb{R}^m$为具有形式<br>$$<br>Tx = Ax + a<br>$$<br>的变换，其中$A$为线性变换,$a\in \mathbb{R}^m$。且满足$$<br>T((1-\lambda)x+\lambda y) = (1-\lambda)Tx + \lambda Ty<br>$$</p>
</li>
<li><p>仿射变换保持仿射凸包性质。</p>
</li>
<li>两个维数相同的仿射集合之间存在唯一一个一一的仿射变换。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/old/">old</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









<!-- 多说评论框 start -->
     <div class="ds-thread" data-thread-key="2015/07/28/2015-07-29-affine_sets/" data-title="Affine sets" data-url="http://yoursite.com/2015/07/28/2015-07-29-affine_sets/"></div>
     <!-- 多说评论框 end -->
     <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
     <script type="text/javascript">
     var duoshuoQuery = {short_name:"hyxue-zeros"};
     	 (function() {
			var ds = document.createElement('script');
			       ds.type = 'text/javascript';ds.async = true;
			       	       	 ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					 	  ds.charset = 'UTF-8';
						  	       (document.getElementsByTagName('head')[0]
									 || document.getElementsByTagName('body')[0]).appendChild(ds);
									    })();
										</script>
										<!-- 多说公共JS代码 end -->
										
  
    <article id="post-Memoize" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/09/13/Memoize/" class="article-date">
  	<time datetime="2014-09-13T12:25:58.000Z" itemprop="datePublished">2014-09-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/13/Memoize/">Memoization in Haskell</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>如果我们需要计算fibonacci数列：</p>
<p>$$<br>f(0) = 0<br>$$</p>
<p>$$<br>f(1) = 1<br>$$</p>
<p>$$<br>f(n) = f(n-1) + f(n-2)<br>$$</p>
<p>那么在命令式语言中，我们必须写一个循环，就这样一个小程序，构造一个循环也许不会费多少脑力和代码，但是我们的程序，终究会变得和我们对fibonacci的定义大相径庭。</p>
<p>在Haskell里面，我们会直接这样写：</p>
<pre><code>f 0 = 0
f 1 = 1
f n = f (n-1) + f (n-2)
</code></pre><p>但是这样会留下很大问题，这样一个递归会让GHC编译器也犯难，于是导致大量的重复计算，结果就和命令式语言里这样写一样成为灾难。</p>
<p>不过我们有Memoization！</p>
<p>Data.Function.Memoize提供了很方便的工具，让我们几乎不用修改原来的递归程序，就能像动态规划（最恶心的东西）一样引入缓存，加快计算。</p>
<pre><code>import Data.Function.Memoize

fib :: Integer -&gt; Integer
fib 0 = 0
fib 1 = 1
fib n = fib&apos; (n-1) + fib&apos; (n-2)

fib&apos; :: Integer -&gt; Integer
fib&apos; = memoize fib

main = print $ log $ fromIntegral $ fib 1000
</code></pre><p>这样的计算要是不用Memoization是不可能进行的。引入memoize以后，速度就和DP的算法一样了。</p>
<h2 id="LCS_Problem"><a href="#LCS_Problem" class="headerlink" title="LCS Problem"></a>LCS Problem</h2><pre><code>import Data.Function.Memoize

lcs a b = f (length a - 1) (length b - 1)
    where
        f 0 0 = 0
        f 0 _ = 0
        f _ 0 = 0
        f n m = if a !! n == b !! m
            then 1 + f&apos; (n-1) (m-1)
            else max (f&apos; (n-1) m) (f&apos; n (m-1))
        f&apos; = memoize2 $ f

main = do
    print $ length a
    print $ length b
    print $ lcs a b
    where
        a =     &quot;1234helloworld2jashdiuafh89q3r9fhahfgsgst64e6hdhdye6e46e46ertydhfnmmxfsea&quot;
        b =     &quot;03424helloworldfdfdfdfd4353645645jnt32897489q24fhakak2901cmnc9724c987438qcp0&quot;
</code></pre><p>带返回的公共字符串</p>
<pre><code>import Data.Function.Memoize

partMax :: (Int,String) -&gt; (Int,String) -&gt; (Int,String)
partMax (a,xs) (b,ys) = if a &gt;= b then (a,xs) else (b,ys) 

lcs a b = f (length a - 1) (length b - 1)
    where
        f 0 0 = (0,[])
        f 0 _ = (0,[])
        f _ 0 = (0,[])
        f n m = if a !! n == b !! m
            then let (len,xs) = f&apos; (n-1) (m-1) in (1+len,((a!!n):xs))
            else partMax (f&apos; (n-1) m) (f&apos; n (m-1))
        f&apos; = memoize2 $ f


main = do
    print $ length a
    print $ length b
    let (z,s) = lcs a b
    print z
    print $ reverse s
    where
        a = &quot;1234helloworld2j3293gdgdg6464642093jdklwjflwewt423412897491274uhrf12rfr12&quot;
        b = &quot;03424helloworldfdfcp043p92jflkf79hhedhey464w6hsry4648721fjbmcvszfq39wnf39804&quot;
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/old/">old</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









<!-- 多说评论框 start -->
     <div class="ds-thread" data-thread-key="2014/09/13/Memoize/" data-title="Memoization in Haskell" data-url="http://yoursite.com/2014/09/13/Memoize/"></div>
     <!-- 多说评论框 end -->
     <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
     <script type="text/javascript">
     var duoshuoQuery = {short_name:"hyxue-zeros"};
     	 (function() {
			var ds = document.createElement('script');
			       ds.type = 'text/javascript';ds.async = true;
			       	       	 ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					 	  ds.charset = 'UTF-8';
						  	       (document.getElementsByTagName('head')[0]
									 || document.getElementsByTagName('body')[0]).appendChild(ds);
									    })();
										</script>
										<!-- 多说公共JS代码 end -->
										
  
    <article id="post-2014-08-31-Haskell_Category" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/08/31/2014-08-31-Haskell_Category/" class="article-date">
  	<time datetime="2014-08-30T16:00:00.000Z" itemprop="datePublished">2014-08-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/31/2014-08-31-Haskell_Category/">Not A Tutorial on Functors, Applicatives, Monads or Arrows</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Haskell有许多非常数学化的深刻思想，这里简单地把它们收集在了一起。注意，这篇文章不是教程，它不会教你这些概念以及如何使用她们，这仅仅是一篇记录而已。</p>
<h2 id="Fix"><a href="#Fix" class="headerlink" title="Fix"></a>Fix</h2><p>这只是一个函数而已，不过她是一个很特殊的函数，</p>
<pre><code>fix :: (a -&gt; a) -&gt; a
fix f = let x = f x in x
</code></pre><p>从表面上看，这是一个可怕的函数，她会变成</p>
<pre><code>f (f (f (f ...
</code></pre><p>这样子的无穷调用，直到你，哦不，是CPU疯掉为止。</p>
<p>不过别忘了Haskell是lazy的，因此有很多情形，fix是可以收敛的。</p>
<p>fix其实是返回f的最小定义不动点的函数，不过此不动点和一般数学里的不动点概念可不完全一样，</p>
<pre><code>fix (*3) 
</code></pre><p>不会收敛，尽管0是</p>
<pre><code>\x-&gt;3*x
</code></pre><p>的不动点，但是还有比她更小的undefined，因此，她不会返回0.</p>
<pre><code>map fix (\f n -&gt; if n == 1 || n == 2 then 1 else f (n-1) + f (n-2)) [1..10]
</code></pre><p>这个会收敛，因为fix f的不动点是fibonacci函数。</p>
<h2 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h2><p>接下来让我们去领略范畴论家族的风采。</p>
<p>首当其冲的便是这个Functor（函子），</p>
<pre><code>class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
    (&lt;$&gt;) :: (a -&gt; b) -&gt; f a -&gt; f b 
</code></pre><h2 id="Applicative"><a href="#Applicative" class="headerlink" title="Applicative"></a>Applicative</h2><p>合用函子。她是介于Monad和Functor之间的一种类型类，是一种特殊的Functor。</p>
<pre><code>class Functor f =&gt; Applicative f where
    pure :: a -&gt; f a
    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b
</code></pre><p>她还有</p>
<p><code>(*&gt;) :: f a -&gt; f b -&gt; f b</code></p>
<p><code>(&lt;*) :: f a -&gt; f b -&gt; f a</code></p>
<p><code>u *&gt; v = pure (const id) &lt;*&gt; u &lt;*&gt; v</code></p>
<p><code>u &lt;* v = pure const &lt;*&gt; u &lt;*&gt; v</code></p>
<h2 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h2><p>最有名的莫过于Monad（单子）了，她是一种特殊的Applicative。</p>
<pre><code>class Monad m where
    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b
    return :: a -&gt; m a
</code></pre><p>在Haskell中，她几乎无处不在。</p>
<h2 id="MonadPlus"><a href="#MonadPlus" class="headerlink" title="MonadPlus"></a>MonadPlus</h2><p>这是一种特殊的Monad。</p>
<pre><code>class Monad m =&gt; MonadPlus m where
    mzero :: m a
    mplus :: m a -&gt; m a -&gt; m a
    mplus mzero m = m
    mplus m mzero = m
    mzero &gt;&gt;= f = mzero
    m &gt;&gt; mzero = mzero
</code></pre><p>MonadPlus的用处主要在于Parsec等场景中，因为她能够像下面一样工作：</p>
<p><code>let f x y = if x == y then Just x else</code></p>
<p><code>Nothing</code></p>
<p><code>mplus (f 10 10) (f 10 1)</code></p>
<p><code>Just 10</code></p>
<p><code>mplus (f 10 1) (f 10 2)</code></p>
<p><code>Nothing</code></p>
<h2 id="Monoid"><a href="#Monoid" class="headerlink" title="Monoid"></a>Monoid</h2><p>幺半群，这个概念对数学的要求应该是最低的，一个代数结构，若是满足群的条件，除了元素不一定有逆元以外，她就是幺半群。</p>
<pre><code>class Monoid a where
    mempty :: a
    mappend :: a -&gt; a -&gt; a
    mconcat :: [a] -&gt; a
</code></pre><p>满足</p>
<pre><code>mappend mempty x = x
mappend x mempty = x
mappend x (mappend y z) = mappend (mappend x y) z
mconcat = foldr mappend mempty
</code></pre><p>mempty是幺半群的单位元，mappend是群的乘法运算。</p>
<h2 id="Arrow"><a href="#Arrow" class="headerlink" title="Arrow"></a>Arrow</h2><p>关于Arrow（箭头）这种东西，很多地方都没有介绍，《Real World Haskell》里面也没有提到过，<br>Arrow确实是一个更加复杂的家伙，她的心思远比之前的那些东西难以捉摸。</p>
<p>Minimal definition：</p>
<pre><code>class Category a =&gt; Arrow a where
    arr  :: (b -&gt; c) -&gt; a b c
    first :: a b c -&gt; a (b,d) (c,d)
    second :: a b c -&gt; a (d,b) (d,c)
    (***) :: a b c -&gt; a b&apos; c&apos; -&gt; a (b,b&apos;) (c,c&apos;)
    (&amp;&amp;&amp;) :: a b c -&gt; a b c&apos; -&gt; a b (c, c&apos;)
</code></pre><p>Monadic function也可以看成是Arrow，她有一个特殊的名字叫做Kleisli arrow。</p>
<pre><code>f :: a -&gt; m b
Kleisli f :: Kleisli m a b
</code></pre><h2 id="ArrowChoice"><a href="#ArrowChoice" class="headerlink" title="ArrowChoice"></a>ArrowChoice</h2><p>ArrowChoice 是带条件的arrow</p>
<pre><code>class Arrow a -&gt; ArrowChoice a where
    left :: a b c -&gt; a (Either b d) (Either c d)
    right :: a b c -&gt; a (Either d b) (Either d c)
    (+++) :: a b c -&gt; a b&apos; c&apos; -&gt; a (Either b b&apos;) (Either c c&apos;)
    (|||) :: a b d -&gt; a c d -&gt; a (Either b c) d
</code></pre><p>事实上，她就是对Either类型所做的一个特例。</p>
<p>以上就是Haskell核心抽象类型类的主要部分，这些东西构成了Haskell强大能力的来源。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/old/">old</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









<!-- 多说评论框 start -->
     <div class="ds-thread" data-thread-key="2014/08/31/2014-08-31-Haskell_Category/" data-title="Not A Tutorial on Functors, Applicatives, Monads or Arrows" data-url="http://yoursite.com/2014/08/31/2014-08-31-Haskell_Category/"></div>
     <!-- 多说评论框 end -->
     <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
     <script type="text/javascript">
     var duoshuoQuery = {short_name:"hyxue-zeros"};
     	 (function() {
			var ds = document.createElement('script');
			       ds.type = 'text/javascript';ds.async = true;
			       	       	 ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					 	  ds.charset = 'UTF-8';
						  	       (document.getElementsByTagName('head')[0]
									 || document.getElementsByTagName('body')[0]).appendChild(ds);
									    })();
										</script>
										<!-- 多说公共JS代码 end -->
										
  
    <article id="post-2014-08-11-HaskellPerformace1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/08/11/2014-08-11-HaskellPerformace1/" class="article-date">
  	<time datetime="2014-08-10T16:00:00.000Z" itemprop="datePublished">2014-08-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/11/2014-08-11-HaskellPerformace1/">Haskell List 和 Vector 性能问题</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由于lazy evaluation的存在，Haskell的性能很是问题。下面来简单看一个例子。<br>我们要对一个列表的元素求和，尽管列表提供了sum函数，但是要是不谨慎使用，依然会引发灾难。</p>
<h3 id="Naive_list_sum"><a href="#Naive_list_sum" class="headerlink" title="Naive list sum"></a>Naive list sum</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">let</span> x = [<span class="number">1.</span><span class="number">.10000000</span>] :: [<span class="type">Int</span>]</span><br><span class="line">    putStr <span class="string">"result = "</span></span><br><span class="line">    print $ sum x</span><br></pre></td></tr></table></figure>
<p>这样一个简单的程序，往往会让初学者陷入灾难。<br>直接编译运行的结果是：大量内存被消耗，运算时间漫长无边，您要是内存小，这么一折腾估计电脑立马就不行了。所以我们小心点编译，给它限制能用的内存大小。</p>
<p><code>$ ghc -rtsopts test.hs</code></p>
<p><code>$ time ./test +RTS -k1M</code></p>
<p>结果是</p>
<p><code>result = Stack space overflow: current size 8388608 bytes.</code></p>
<p>你一定想问了，就这么个求和，用得着那么多内存吗？没办法，谁叫Haskell的特性如此呢，它要把中间的计算式全部保存下来，最后再消去。</p>
<h3 id="O2_Optimization"><a href="#O2_Optimization" class="headerlink" title="-O2 Optimization"></a>-O2 Optimization</h3><p>GHC 有个-O2的编译选项，如果我们打开这个优化，</p>
<p><code>$ ghc -O2 -rtsopts test.hs</code></p>
<p>那么结果皆大欢喜</p>
<p><code>$ time ./test +RTS -k1M</code></p>
<p><code>result = 50000005000000</code></p>
<p><code>real    0m0.174s</code></p>
<p><code>user    0m0.164s</code></p>
<p><code>sys    0m0.008s</code></p>
<h3 id="Adding_Strictness"><a href="#Adding_Strictness" class="headerlink" title="Adding Strictness"></a>Adding Strictness</h3><p>-O2优化虽然厉害，但是不是万能的，编译器的优化能力毕竟有限。-O2实际上编译器优化了那些可以严格求值的地方，避免了大规模thunk的堆积。我们在自己实现函数的时候，也可以指定某些地方要严格求值，这是写出高性能haskell程序的关键。</p>
<p>来看这个例子，其中<code>seq</code>是一个指定严格计算的函数。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="import"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Vector.Unboxed <span class="keyword">as</span> V</span></span><br><span class="line"><span class="title">mySum</span> :: [<span class="type">Int</span>] -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> </span><br><span class="line"><span class="title">mySum</span> [] x = x</span><br><span class="line"><span class="title">mySum</span> (x:xs) y = <span class="keyword">let</span> z = x + y <span class="keyword">in</span> z `seq` mySum xs z</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">let</span> x = [<span class="number">1.</span><span class="number">.10000000</span>] :: [<span class="type">Int</span>]</span><br><span class="line">	putStr <span class="string">"result = "</span></span><br><span class="line">	print $ mySum x <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>不开优化</p>
<p><code>$ ghc -rtsopts test.hs</code></p>
<p><code>$ time ./test +RTS -k1M</code></p>
<p>结果不错，</p>
<p><code>result = 50000005000000</code></p>
<p><code>real    0m0.266s</code></p>
<p><code>user    0m0.256s</code><br><code>sys    0m0.008s</code></p>
<p>开了优化的结果</p>
<p><code>result = 50000005000000</code></p>
<p><code>real    0m0.170s</code></p>
<p><code>user    0m0.160s</code></p>
<p><code>sys    0m0.008s</code></p>
<p>可以说开不开优化结果不相上下。但是优化总是好的嘛！</p>
<h3 id="Data-Vector-Unboxed"><a href="#Data-Vector-Unboxed" class="headerlink" title="Data.Vector.Unboxed"></a>Data.Vector.Unboxed</h3><p>Haskell默认的List性能实际上是相当捉急的，一般我们要用Vector来替代它。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="import"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Vector.Unboxed <span class="keyword">as</span> V</span></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">let</span> x = [<span class="number">1.</span><span class="number">.10000000</span>] :: [<span class="type">Int</span>]</span><br><span class="line">	putStr <span class="string">"result = "</span></span><br><span class="line">	print $ <span class="type">V</span>.sum $ <span class="type">V</span>.enumFromTo <span class="number">1</span> (<span class="number">10000000</span>::<span class="type">Int</span>)</span><br></pre></td></tr></table></figure>
<p><code>$ ghc -rtsopts -O2 test.hs</code></p>
<p><code>$ time ./test +RTS -k1M</code></p>
<p><code>result = 50000005000000</code></p>
<p><code>real    0m0.020s</code></p>
<p><code>user    0m0.012s</code></p>
<p><code>sys    0m0.004s</code></p>
<p>开了优化以后居然只用0.020s，速度远超前面的程序，尽管若是不开优化耗时得有1.2s左右。另外就算用普通的Data.Vector，优化后的速度也比List快很多，因此，能用Vector和Array就尽量用它们而不要用List吧。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/old/">old</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









<!-- 多说评论框 start -->
     <div class="ds-thread" data-thread-key="2014/08/11/2014-08-11-HaskellPerformace1/" data-title="Haskell List 和 Vector 性能问题" data-url="http://yoursite.com/2014/08/11/2014-08-11-HaskellPerformace1/"></div>
     <!-- 多说评论框 end -->
     <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
     <script type="text/javascript">
     var duoshuoQuery = {short_name:"hyxue-zeros"};
     	 (function() {
			var ds = document.createElement('script');
			       ds.type = 'text/javascript';ds.async = true;
			       	       	 ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					 	  ds.charset = 'UTF-8';
						  	       (document.getElementsByTagName('head')[0]
									 || document.getElementsByTagName('body')[0]).appendChild(ds);
									    })();
										</script>
										<!-- 多说公共JS代码 end -->
										
  
    <article id="post-2014-07-26-brainfuck2c" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/07/26/2014-07-26-brainfuck2c/" class="article-date">
  	<time datetime="2014-07-25T16:00:00.000Z" itemprop="datePublished">2014-07-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/07/26/2014-07-26-brainfuck2c/">Brainfuck到C的翻译器</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Brainfuck__u5230_C__u7684_u7FFB_u8BD1_u5668"><a href="#Brainfuck__u5230_C__u7684_u7FFB_u8BD1_u5668" class="headerlink" title="Brainfuck 到 C 的翻译器"></a>Brainfuck 到 C 的翻译器</h2><p><a href="http://baike.baidu.com/view/765703.htm?fr=aladdin" target="_blank" rel="external">brainfuck</a>是一个非常神奇的语言，闲来无事，就用haskell写了一个brainfuck到C语言的简单翻译器。</p>
<p>相当的粗制滥造，不过一般用用没有问题。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&#123;-</span><br><span class="line">	A crudely made simple brainfuck 		direct C translator</span><br><span class="line">	It translates brainfuck code into 		plain C code</span><br><span class="line">-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="import"><span class="keyword">import</span> Text.ParserCombinators.Parsec</span></span><br><span class="line"><span class="import"><span class="keyword">import</span> Control.Applicative <span class="keyword">hiding</span><span class="container">((&lt;|&gt;)</span>,many)</span></span><br><span class="line"><span class="import"><span class="keyword">import</span> Text.Regex.Posix</span></span><br><span class="line"></span><br><span class="line"><span class="title">sumlist'</span> xx = aux xx <span class="number">0</span></span><br><span class="line">   	<span class="keyword">where</span> aux [] a = []</span><br><span class="line">         	aux (x:xs) a = (a+x) : aux xs (a+x)</span><br><span class="line"></span><br><span class="line"><span class="title">size</span> :: [<span class="type">String</span>] -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">size</span> s = maximum $ sumlist' $ zipWith (+) ((\x -&gt; x =~ <span class="string">"ptr[++]"</span>) &lt;$&gt; s) ((\x -&gt; x =~ <span class="string">"ptr[--]"</span>) &lt;$&gt; s)</span><br><span class="line"></span><br><span class="line"><span class="title">bfParser</span> :: <span class="type">GenParser</span> <span class="type">Char</span> st [<span class="type">String</span>]</span><br><span class="line"><span class="title">bfParser</span> = <span class="keyword">do</span></span><br><span class="line">	insn &lt;- many instruction</span><br><span class="line">	eof</span><br><span class="line">	return insn</span><br><span class="line"></span><br><span class="line"><span class="title">comment</span> = many1 (noneOf <span class="string">"&lt;&gt;+-.,[]"</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">instruction</span> :: <span class="type">GenParser</span> <span class="type">Char</span> st <span class="type">String</span></span><br><span class="line"><span class="title">instruction</span> = moveForward &lt;|&gt; moveBackward &lt;|&gt; increment &lt;|&gt; decrement</span><br><span class="line">	&lt;|&gt; outputInstr &lt;|&gt; inputInstr &lt;|&gt; loopBegin &lt;|&gt; loopEnd &lt;|&gt;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	  comment</span><br><span class="line">	  return []</span><br><span class="line"></span><br><span class="line"><span class="title">moveForward</span>, moveBackward, increment, decrement, outputInstr,</span><br><span class="line"> 	 inputInstr,loopBegin,loopEnd :: <span class="type">GenParser</span> <span class="type">Char</span> st <span class="type">String</span></span><br><span class="line"></span><br><span class="line"><span class="title">moveForward</span> = <span class="keyword">do</span></span><br><span class="line"><span class="title">char</span> '&gt;'</span><br><span class="line"><span class="title">return</span> <span class="string">"ptr++;\n"</span></span><br><span class="line"></span><br><span class="line"><span class="title">moveBackward</span> = <span class="keyword">do</span></span><br><span class="line">	char '&lt;'</span><br><span class="line">	return <span class="string">"ptr--;\n"</span></span><br><span class="line"></span><br><span class="line"><span class="title">increment</span> = <span class="keyword">do</span></span><br><span class="line">	char '+'</span><br><span class="line">	return <span class="string">"++*ptr;\n"</span></span><br><span class="line"></span><br><span class="line"><span class="title">decrement</span> = <span class="keyword">do</span></span><br><span class="line">	char '-'</span><br><span class="line">	return <span class="string">"--*ptr;\n"</span></span><br><span class="line"></span><br><span class="line"><span class="title">outputInstr</span> = <span class="keyword">do</span></span><br><span class="line">	char '.'</span><br><span class="line">	return <span class="string">"putchar(*ptr);\n"</span></span><br><span class="line"></span><br><span class="line"><span class="title">inputInstr</span> = <span class="keyword">do</span></span><br><span class="line">	char ','</span><br><span class="line">	return <span class="string">"*ptr=getchar();\n"</span></span><br><span class="line"></span><br><span class="line"><span class="title">loopBegin</span> = <span class="keyword">do</span></span><br><span class="line">	char '['</span><br><span class="line">	return <span class="string">"while(*ptr)&#123;\n"</span></span><br><span class="line"></span><br><span class="line"><span class="title">loopEnd</span> = <span class="keyword">do</span></span><br><span class="line">	char ']'</span><br><span class="line">	return <span class="string">"&#125;\n"</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">	code &lt;- getContents</span><br><span class="line">	<span class="keyword">case</span> parse bfParser <span class="string">"Error"</span> code <span class="keyword">of</span> </span><br><span class="line">	<span class="type">Left</span> e -&gt; putStrLn $ show e</span><br><span class="line">	<span class="type">Right</span> r -&gt; <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">let</span> header = <span class="string">"#include &lt;stdio.h&gt;\n"</span></span><br><span class="line">		<span class="keyword">let</span> n = size r + <span class="number">1</span></span><br><span class="line">		<span class="keyword">let</span> declare = <span class="string">"int array["</span> ++ show n ++ <span class="string">"];\n"</span> ++</span><br><span class="line">		              <span class="string">"int i = 0;\n"</span> ++</span><br><span class="line">		              <span class="string">"for(i=0;i&lt;"</span> ++ show n ++ <span class="string">";i++)&#123;\n"</span> ++</span><br><span class="line">		              <span class="string">"array[i]=0;\n&#125;\n"</span></span><br><span class="line">		<span class="keyword">let</span> complete = header ++ <span class="string">"int main() &#123;\n"</span> ++ declare </span><br><span class="line">		     ++ <span class="string">"int *ptr = array;\n"</span></span><br><span class="line">		     ++ concat r ++ <span class="string">"return 0;\n&#125;\n"</span></span><br><span class="line">		putStrLn $ complete</span><br></pre></td></tr></table></figure>
<p>接下来我们来试一试一些代码</p>
<h3 id="Hello_world"><a href="#Hello_world" class="headerlink" title="Hello world"></a>Hello world</h3><pre><code>++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]
&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.
&gt;.+++.------.--------.&gt;+.&gt;.        

./bf &lt; code.bf &gt; result.c
</code></pre><p>下面是翻译的结果result.c：</p>
<p>代码是直译过去的，显然不是给人看的，<br>要是想产生可读性高的C代码，还得在翻译程序上下点功夫<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">17</span>];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">17</span>;i++)&#123;</span><br><span class="line"><span class="built_in">array</span>[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> *ptr = <span class="built_in">array</span>;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line"><span class="keyword">while</span>(*ptr)&#123;</span><br><span class="line">ptr++;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">ptr++;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">ptr++;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">ptr++;</span><br><span class="line">++*ptr;</span><br><span class="line">ptr--;</span><br><span class="line">ptr--;</span><br><span class="line">ptr--;</span><br><span class="line">ptr--;</span><br><span class="line">--*ptr;</span><br><span class="line">&#125;</span><br><span class="line">ptr++;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line"><span class="built_in">putchar</span>(*ptr);</span><br><span class="line">ptr++;</span><br><span class="line">++*ptr;</span><br><span class="line"><span class="built_in">putchar</span>(*ptr);</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line"><span class="built_in">putchar</span>(*ptr);</span><br><span class="line"><span class="built_in">putchar</span>(*ptr);</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line"><span class="built_in">putchar</span>(*ptr);</span><br><span class="line">ptr++;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line"><span class="built_in">putchar</span>(*ptr);</span><br><span class="line">ptr--;</span><br><span class="line">ptr--;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line"><span class="built_in">putchar</span>(*ptr);</span><br><span class="line">ptr++;</span><br><span class="line"><span class="built_in">putchar</span>(*ptr);</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line">++*ptr;</span><br><span class="line"><span class="built_in">putchar</span>(*ptr);</span><br><span class="line">--*ptr;</span><br><span class="line">--*ptr;</span><br><span class="line">--*ptr;</span><br><span class="line">--*ptr;</span><br><span class="line">--*ptr;</span><br><span class="line">--*ptr;</span><br><span class="line"><span class="built_in">putchar</span>(*ptr);</span><br><span class="line">--*ptr;</span><br><span class="line">--*ptr;</span><br><span class="line">--*ptr;</span><br><span class="line">--*ptr;</span><br><span class="line">--*ptr;</span><br><span class="line">--*ptr;</span><br><span class="line">--*ptr;</span><br><span class="line">--*ptr;</span><br><span class="line"><span class="built_in">putchar</span>(*ptr);</span><br><span class="line">ptr++;</span><br><span class="line">++*ptr;</span><br><span class="line"><span class="built_in">putchar</span>(*ptr);</span><br><span class="line">ptr++;</span><br><span class="line"><span class="built_in">putchar</span>(*ptr);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>没错，编译这段C程序，执行就可以得到hello world了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/old/">old</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









<!-- 多说评论框 start -->
     <div class="ds-thread" data-thread-key="2014/07/26/2014-07-26-brainfuck2c/" data-title="Brainfuck到C的翻译器" data-url="http://yoursite.com/2014/07/26/2014-07-26-brainfuck2c/"></div>
     <!-- 多说评论框 end -->
     <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
     <script type="text/javascript">
     var duoshuoQuery = {short_name:"hyxue-zeros"};
     	 (function() {
			var ds = document.createElement('script');
			       ds.type = 'text/javascript';ds.async = true;
			       	       	 ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					 	  ds.charset = 'UTF-8';
						  	       (document.getElementsByTagName('head')[0]
									 || document.getElementsByTagName('body')[0]).appendChild(ds);
									    })();
										</script>
										<!-- 多说公共JS代码 end -->
										
  
    <article id="post-2014-07-16-Haskell_20" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/07/16/2014-07-16-Haskell_20/" class="article-date">
  	<time datetime="2014-07-15T16:00:00.000Z" itemprop="datePublished">2014-07-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/07/16/2014-07-16-Haskell_20/">20 Intermediate Haskell Exercises</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="20_Intermediate_Haskell_Exercises"><a href="#20_Intermediate_Haskell_Exercises" class="headerlink" title="20 Intermediate Haskell Exercises"></a>20 Intermediate Haskell Exercises</h2><pre><code>class Fluffy f where
furry :: (a -&gt; b) -&gt; f a -&gt; f b

-- Exercise 1
-- Relative Difficulty: 1
instance Fluffy [] where
furry = error &quot;todo&quot;

-- Exercise 2
-- Relative Difficulty: 1
instance Fluffy Maybe where
furry = error &quot;todo&quot;

-- Exercise 3
-- Relative Difficulty: 5
instance Fluffy ((-&gt;) t) where
furry = error &quot;todo&quot;

newtype EitherLeft b a = EitherLeft (Either a b)
newtype EitherRight a b = EitherRight (Either a b)

-- Exercise 4
-- Relative Difficulty: 5
instance Fluffy (EitherLeft t) where
furry = error &quot;todo&quot;

-- Exercise 5
-- Relative Difficulty: 5
instance Fluffy (EitherRight t) where
furry = error &quot;todo&quot;

class Misty m where
banana :: (a -&gt; m b) -&gt; m a -&gt; m b
unicorn :: a -&gt; m a
-- Exercise 6
-- Relative Difficulty: 3
-- (use banana and/or unicorn)
furry&apos; :: (a -&gt; b) -&gt; m a -&gt; m b
furry&apos; = error &quot;todo&quot;

-- Exercise 7
-- Relative Difficulty: 2
instance Misty [] where
banana = error &quot;todo&quot;
unicorn = error &quot;todo&quot;

-- Exercise 8
-- Relative Difficulty: 2
instance Misty Maybe where
banana = error &quot;todo&quot;
unicorn = error &quot;todo&quot;

-- Exercise 9
-- Relative Difficulty: 6
instance Misty ((-&gt;) t) where
banana = error &quot;todo&quot;
unicorn = error &quot;todo&quot;

-- Exercise 10
-- Relative Difficulty: 6
instance Misty (EitherLeft t) where
banana = error &quot;todo&quot;
unicorn = error &quot;todo&quot;

-- Exercise 11
-- Relative Difficulty: 6
instance Misty (EitherRight t) where
banana = error &quot;todo&quot;
unicorn = error &quot;todo&quot;

-- Exercise 12
-- Relative Difficulty: 3
jellybean :: (Misty m) =&gt; m (m a) -&gt; m a
jellybean = error &quot;todo&quot;

-- Exercise 13
-- Relative Difficulty: 6
apple :: (Misty m) =&gt; m a -&gt; m (a -&gt; b) -&gt; m b
apple = error &quot;todo&quot;

-- Exercise 14
-- Relative Difficulty: 6
moppy :: (Misty m) =&gt; [a] -&gt; (a -&gt; m b) -&gt; m [b]
moppy = error &quot;todo&quot;

-- Exercise 15
-- Relative Difficulty: 6
-- (bonus: use moppy)
sausage :: (Misty m) =&gt; [m a] -&gt; m [a]
sausage = error &quot;todo&quot;

-- Exercise 16
-- Relative Difficulty: 6
-- (bonus: use apple + furry&apos;)
banana2 :: (Misty m) =&gt; (a -&gt; b -&gt; c) -&gt; m a -&gt; m b -&gt; m c
banana2 = error &quot;todo&quot;

-- Exercise 17
-- Relative Difficulty: 6
-- (bonus: use apple + banana2)
banana3 :: (Misty m) =&gt; (a -&gt; b -&gt; c -&gt; d) -&gt; m a -&gt; m b -&gt; m c -&gt; m d
banana3 = error &quot;todo&quot;

-- Exercise 18
-- Relative Difficulty: 6
-- (bonus: use apple + banana3)
banana4 :: (Misty m) =&gt; (a -&gt; b -&gt; c -&gt; d -&gt; e) -&gt; m a -&gt; m b -&gt; m c -&gt; m d -&gt; m e
banana4 = error &quot;todo&quot;

newtype State s a = State {
state :: (s -&gt; (s, a))
}

-- Exercise 19
-- Relative Difficulty: 9
instance Fluffy (State s) where
furry = error &quot;todo&quot;

-- Exercise 20
-- Relative Difficulty: 10
instance Misty (State s) where
banana = error &quot;todo&quot;
unicorn = error &quot;todo&quot;
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Haskell/">Haskell</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









<!-- 多说评论框 start -->
     <div class="ds-thread" data-thread-key="2014/07/16/2014-07-16-Haskell_20/" data-title="20 Intermediate Haskell Exercises" data-url="http://yoursite.com/2014/07/16/2014-07-16-Haskell_20/"></div>
     <!-- 多说评论框 end -->
     <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
     <script type="text/javascript">
     var duoshuoQuery = {short_name:"hyxue-zeros"};
     	 (function() {
			var ds = document.createElement('script');
			       ds.type = 'text/javascript';ds.async = true;
			       	       	 ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					 	  ds.charset = 'UTF-8';
						  	       (document.getElementsByTagName('head')[0]
									 || document.getElementsByTagName('body')[0]).appendChild(ds);
									    })();
										</script>
										<!-- 多说公共JS代码 end -->
										
  
    <article id="post-2014-05-19-FFI2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/05/19/2014-05-19-FFI2/" class="article-date">
  	<time datetime="2014-05-18T16:00:00.000Z" itemprop="datePublished">2014-05-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/19/2014-05-19-FFI2/">Real My Haskell (3)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Haskell_u4F7F_u7528_u5916_u90E8C_u51FD_u6570__282_29__26amp_3B_State_Monad__26amp_3B_ST_Monad"><a href="#Haskell_u4F7F_u7528_u5916_u90E8C_u51FD_u6570__282_29__26amp_3B_State_Monad__26amp_3B_ST_Monad" class="headerlink" title="Haskell使用外部C函数 (2) &amp; State Monad &amp; ST Monad"></a>Haskell使用外部C函数 (2) &amp; State Monad &amp; ST Monad</h2><h3 id="FFI__282_29"><a href="#FFI__282_29" class="headerlink" title="FFI (2)"></a>FFI (2)</h3><p>  我们已经看到了如何在Haskell中使用外部C函数，现在让我们来看一个稍微复杂些的实际的例子，通过FFI使用Linux的系统调用<strong>gettimeofday</strong>。</p>
<p>  首先<strong>man</strong>一下，我们可以得到重要的两个结构体的信息：</p>
<pre><code>-- definitions
int gettimeofday(struct timeval *tv, struct timezone *tz);

struct timeval {
time_t      tv_sec;     /* seconds */
suseconds_t tv_usec;    /* microseconds */
};

struct timezone {
int tz_minuteswest;     /* minutes west of Greenwich */
int tz_dsttime;         /* type of DST correction */
};
</code></pre><p>注意到两个特殊的类型<strong>time_t</strong>和<strong>suseconds_t</strong>在我的系统中其实就是<strong>long int</strong>，对应haskell中的Int。<br>于是为简便起见，就不再为这两个数据类型做另外的定义了。</p>
<p>接下来一次性奉上所有Haskell的代码，这是 <strong>time.hcs</strong> 文件里面的内容：</p>
<pre><code>{-# LANGUAGE ForeignFunctionInterface #-}
import Foreign
import Foreign.C.Types
import Foreign.Ptr

foreign import ccall unsafe &quot;sys/time/.h gettimeofday&quot; 
c_gettimeofday :: TimeValPtr -&gt; TimeZonePtr -&gt; IO CInt

data TimeZone = TimeZone {tz_MinutesWest :: CInt, tz_DstTime :: CInt}
data TimeVal = TimeVal {tv_Sec :: Int, tv_Usec :: Int}

type TimeValPtr = Ptr TimeVal
type TimeZonePtr = Ptr TimeZone

#include &quot;time.h&quot;
#include &quot;time1.h&quot;
#let alignment t = &quot;%lu&quot;, (unsigned long)offsetof(struct {char x__; t (y__); }, y__)
instance Storable TimeVal where
sizeOf _ = (#size struct timeval) 
alignment _ = #{alignment struct timeval} 
peek ptr = do
tv_sec&apos;  &lt;- (#peek struct timeval,tv_sec) ptr
tv_usec&apos; &lt;- (#peek struct timeval,tv_usec) ptr
return TimeVal {tv_Sec = tv_sec&apos;,tv_Usec = tv_usec&apos;}
poke ptr (TimeVal tv_sec&apos; tv_usec&apos;) = do
(#poke struct timeval, tv_sec)  ptr tv_sec&apos;
(#poke struct timeval, tv_usec) ptr tv_usec&apos;

instance Storable TimeZone where
sizeOf _ = (#size struct timezone) 
alignment _ = #{alignment struct timezone} 
peek ptr = do
tz_minuteswest&apos;  &lt;- (#peek struct timezone,tz_minuteswest) ptr
tz_dsttime&apos; &lt;- (#peek struct timezone,tz_dsttime) ptr
return TimeZone {tz_MinutesWest = tz_minuteswest&apos;,tz_DstTime = tz_dsttime&apos;}
poke ptr (TimeZone tz_minuteswest&apos; tz_dsttime&apos;) = do
(#poke struct timezone, tz_minuteswest)  ptr tz_minuteswest&apos;
(#poke struct timezone, tz_dsttime) ptr tz_dsttime&apos;

-- using either to deal with potential exceptions raised by gettimeofday
hs_getTimeOfDay :: IO (Either TimeVal String)
hs_getTimeOfDay = alloca $ \tval -&gt; do 
i &lt;- c_gettimeofday tval nullPtr
if (i == -1) then return $ Right &quot;error&quot;
else do 
timeVal &lt;- peek tval 
return $ Left timeVal


main = do
eitherTimeVal &lt;- hs_getTimeOfDay
case eitherTimeVal of
Left timeVal -&gt; do 
print $ tv_Sec timeVal
print $ tv_Usec timeVal
Right s -&gt; print s



-- preprocess and compile
hsc2hs time.hcs
ghc time.hs
</code></pre><p>好了，到现在为止，我们已经基本掌握了FFI的使用了。</p>
<h3 id="State_Monad"><a href="#State_Monad" class="headerlink" title="State Monad"></a>State Monad</h3><p>现在，我把目光投向另外的内容，一个<em>状态单子</em>（<em>State Monad</em>），这个东西虽说和<em>IO</em>，<em>Maybe</em>等等的<em>Monad</em>都是同一个模子<br>里面出来的，但是对我而言，其他的<em>单子</em>（<em>Monad</em>）很好理解，只有这个<em>状态单子</em>，似乎总是捉摸不定。</p>
<p>先来看一个Haskell的wiki上最常见的例子，随机数生成。</p>
<p>众所周知，计算机的随机数其实都是伪随机数，需要输入一个种子，然后算法会吐给你一串看上去像是随机的数列，<br>Haskell中的<em>random</em>函数就是这样的：<em>random :: (RandomGen g, Random a) =&gt; g -&gt; (a, g)</em>,<br>利用seed生成一个随机数，然后返回新的seed。</p>
<p>如果我们想要获得多个随机数，当然可以不厌其烦的显式地获得每一次的状态，然后传给下一次的调用。<br>不过状态单子使得我们能够不用显性地传递这些状态：</p>
<pre><code>-- Random Number
import Control.Monad.State
import System.Random
myRandom :: (Random a) =&gt; State StdGen a
myRandom = do   -- (State s a)
g &lt;- get    -- (State s s)
(x,g&apos;) &lt;- return $ random g       --(random g -&gt; (Int, StdGen)) =&gt; State s (x,g&apos;)
put g&apos;                            -- State g&apos; (x,g&apos;)
return x                          -- State g&apos; x

genNRandom :: StdGen -&gt; ([Int],StdGen)
genNRandom = runState $ do 
n &lt;- myRandom
m &lt;- myRandom
return [m,n]

main = do
let a = genNRandom $ mkStdGen 1
print $ fst a
</code></pre><p>以上就是wiki上面的头号例子，对我而言它也是最臭名昭著的例子，因为我曾无数次地阅读它，但是仍然cannot figure out anything！<br>确切地说，不是弄不懂这个例子，是这个例子太容易明白了，但是仅有这个例子，实在难以推广到其它用途。</p>
<p>在阅读了大量资料以后，终于才有了头绪。<br>事实上，在FP编程中，这种递归函数<em>中间变量</em>（<em>状态</em>）的传递其实是很常见的，有些变量在我们的最终计算结果中不起任何作用，但是<br>计算的过程离不开它，于是我们需要在函数中为它留一个“正位”。</p>
<p>比如</p>
<pre><code>factorial‘ 0 x = x
factorial’ n x = factorial‘ (n-1) (x*n)

factorial n = factorial&apos; n 1
</code></pre><p>就是最常见的类型，对于小的函数，这样做倒也无所谓，对于大的函数，这样做可能会有麻烦。<br>设想一个函数<em>f :: a -&gt; b -&gt; c -&gt; … -&gt; z</em>，如果你还得加上这些要传递的状态，那得多么麻烦！</p>
<p>另外尽管FP的思想更符合许多算法的本质，但仍然有许多算法，涉及到状态的改变，它们用操作序列的方式来定义更加自然和方便。<br>这样，使用<em>状态单子</em>，则方便多了。<em>状态单子</em>最重要的一点就是让我们能够在FP的程序中，在<em>有必要</em>的时候，依然能够按照命令式语言的风格进行编程。</p>
<p>比如下面这个，是阶乘的<em>State Monad</em>版本，</p>
<pre><code>-- State Monad Factorial
type FactorialState = Int
type FactorialValue = Int
fact :: Int -&gt; State FactorialState FactorialValue
fact 0 = do
state &lt;- get
return state
fact n = do
state &lt;- get
put (state * n)
fact (n-1)
myfactorial :: Int -&gt; Int
myfactorial n = evalState (fact n) 1
</code></pre><p>当然，到这里你可能还是没有懂一些细节，接下来我们就来看细节,<br>假定你有一个奇怪的机器，放置在一个电梯门口对面，它会每个一个固定时间测量某个东西，测量的结果要么是1要么是2，<br>每当电梯门打开或者关闭时机器会自己记录下一个0。</p>
<p>而且测量结果只有在电梯门打开的时候是有效的，也就是说，在电梯门关闭着的时候，测量的结果都应该被扔掉！</p>
<p>现在我们有一串机器获得的序列，假设开始测量时电梯门是关着的，现在请你将所有有效的测量数据求和。</p>
<p>我们来写一个处理程序：</p>
<p>首先我们定义一些数据类型：</p>
<pre><code>--data types
type Switch = Bool
type Value = Int
type MachineState = (Switch,Value)
</code></pre><p>Switch是开关，表明现在的数据是否有效，我们的处理程序是一个一个字符工作的，<br>就好像一台包装机，一件件物品流过去，然后一件件的包装，因此每处理完一个字符，处理机都拥有了一个新状态<em>MachineState</em>,<br>它包括，当前数据是否有效（门是否开着），和当前的有效数据和。</p>
<p>这是我们的处理机程序，注意到它接收测量字符串<em>String</em>，然后返回了一个状态单子！！</p>
<pre><code>-- process
process :: String -&gt; State MachineState Value
process [] = do              -- State (switch,val) _
(switch,val) &lt;- get      -- State (switch,val) (switch,val)
return val               -- State (switch,val) val
process (x:xs) = do
(switch,val) &lt;- get      -- State (switch,val) (switch,val)
case x of
&apos;1&apos; -&gt; put (if switch then (switch, val + 1) else (switch, val))
&apos;2&apos; -&gt; put (if switch then (switch, val + 2) else (switch, val))
&apos;#&apos; -&gt; put (not switch,val)                    -- State (not switch,val) val

process xs
</code></pre><p>接下来，我们一步一步分析，</p>
<pre><code>-- 假设某一时刻状态单子为 State mystate myvalue
-- get的作用是将 State mystate myvalue 变为 State mystate mystate,
-- 即 State mystate myvalue -&gt; State mystate mystate
-- 因此下面那句话的作用是获得当前的状态
(switch,val) &lt;- get      

-- 我们对遇到的字符分情况讨论，
-- put的作用是改变当前的状态， 但不改变值，
-- 即 myNewState -&gt; State mystate myvalue -&gt; State myNewState myvalue
case x of
&apos;1&apos; -&gt; put (if switch then (switch, val + 1) else (switch, val))
&apos;2&apos; -&gt; put (if switch then (switch, val + 2) else (switch, val))
&apos;#&apos; -&gt; put (not switch,val)                    -- State (not switch,val) val

-- return的作用是给状态单子赋值，但不改变状态。      
return val  
</code></pre><p>这样子分析，就能够明白状态单子的工作是正确无误的。</p>
<p>事实上，最令人无法理解的就是，我们一直在用get，put这些函数，可是状态到底在哪里呢？<br>只要想通这一点，所有困惑都会迎刃而解了。</p>
<p>真正的状态实际上被隐藏了起来，下面这个函数使用了<em>evalState</em>，它能够在给定初始状态的条件下，执行我们的处理机。</p>
<p><em>我们所有的状态操作，都是在evalState的“监管”下完成的。</em> 因此状态被自动维护了，不再需要我们去操心状态的传递，<br>只要我们写好正确的处理逻辑，然后指定初始状态(False,0),（关着门，测量和为0），就可以执行整个流程获得我们想要的结果。</p>
<pre><code>execProcess :: String -&gt; Int
execProcess str = evalState (process str) (False,0)

-- A strange machine
import Control.Monad.State

type Switch = Bool
type Value = Int
type MachineState = (Switch,Value)
process :: String -&gt; State MachineState Value
process [] = do              -- State (switch,val) _
(switch,val) &lt;- get      -- State (switch,val) (switch,val)
return val               -- State (switch,val) val
process (x:xs) = do
(switch,val) &lt;- get      -- State (switch,val) (switch,val)
case x of
&apos;1&apos; -&gt; put (if switch then (switch, val + 1) else (switch, val))
&apos;2&apos; -&gt; put (if switch then (switch, val + 2) else (switch, val))
&apos;#&apos; -&gt; put (not switch,val)                    -- State (not switch,val) val

process xs

execProcess :: String -&gt; Int
execProcess str = evalState (process str) (False,0)

main = print $ execProcess &quot;1211#122111#12222#1121#1&quot;
</code></pre><p>例子中的结果是13。显然是正确的。</p>
<h3 id="ST_Monad"><a href="#ST_Monad" class="headerlink" title="ST Monad"></a>ST Monad</h3><p>ST Monad 和 State Monad其实功能上是差不多的，都是一种状态Monad，只不过State Monad是pure functional的，<br>也就是说，本质上，状态是不可改变的，只不过新状态是传递了下来而已。而ST Monad则允许真正修改状态在内存中的值。</p>
<p>比如同样是要求一个列表的和，使用两种Monad都可以实现，</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- ST vs State</span></span><br><span class="line"><span class="import"><span class="keyword">import</span> Control.Monad.State</span></span><br><span class="line"><span class="import"><span class="keyword">import</span> Control.Monad.ST</span></span><br><span class="line"><span class="import"><span class="keyword">import</span> Data.STRef</span></span><br><span class="line"><span class="title">process</span> :: [<span class="type">Integer</span>] -&gt; <span class="type">State</span> <span class="type">Integer</span> <span class="type">Integer</span></span><br><span class="line"><span class="title">process</span> [] = <span class="keyword">do</span></span><br><span class="line">	mysum &lt;- get</span><br><span class="line">	return mysum</span><br><span class="line"><span class="title">process</span> (x:xs) = <span class="keyword">do</span></span><br><span class="line">	mysum &lt;- get</span><br><span class="line">	put $ mysum + x</span><br><span class="line">	process xs</span><br><span class="line">	</span><br><span class="line"><span class="title">sumState</span> :: [<span class="type">Integer</span>] -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">sumState</span> x = evalState (process x) <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="title">sumST</span> :: [<span class="type">Integer</span>] -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">sumST</span> xs = runST $ <span class="keyword">do</span></span><br><span class="line">	n &lt;- newSTRef <span class="number">0</span></span><br><span class="line">	forM_ xs $ \x -&gt; <span class="keyword">do</span></span><br><span class="line">		a &lt;- readSTRef n</span><br><span class="line">		writeSTRef n $ (x + a)</span><br><span class="line">	readSTRef n</span><br><span class="line">		</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">	print $ sumState [<span class="number">1.</span><span class="number">.10</span>]</span><br><span class="line">	print $ sumST [<span class="number">1.</span><span class="number">.10</span>]</span><br></pre></td></tr></table></figure>
<p>不过我们可以注意到，使用ST Monad的代码更接近命令式语言的风格。</p>
<h3 id="u7528_u9014"><a href="#u7528_u9014" class="headerlink" title="用途"></a>用途</h3><p>我们已经看到了两种跟状态有关的Monad，那么什么时候使用这一个，什么时候使用另一个呢？</p>
<p>根据Haskell wiki上的介绍，</p>
<ul>
<li><p>当我们在一个单线程的控制程序中需要状态的时候，一般使用State Monad，比如前面那个奇怪机器的数据处理，我们需要关于<br>电梯门的状态。</p>
</li>
<li><p>ST Monad主要用来实现可变的数组和其他数据结构，可变是指能够原地修改（类似指针），而不用返回新的数据结构。这样可以获得高效的数据结构操作。</p>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/old/">old</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









<!-- 多说评论框 start -->
     <div class="ds-thread" data-thread-key="2014/05/19/2014-05-19-FFI2/" data-title="Real My Haskell (3)" data-url="http://yoursite.com/2014/05/19/2014-05-19-FFI2/"></div>
     <!-- 多说评论框 end -->
     <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
     <script type="text/javascript">
     var duoshuoQuery = {short_name:"hyxue-zeros"};
     	 (function() {
			var ds = document.createElement('script');
			       ds.type = 'text/javascript';ds.async = true;
			       	       	 ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					 	  ds.charset = 'UTF-8';
						  	       (document.getElementsByTagName('head')[0]
									 || document.getElementsByTagName('body')[0]).appendChild(ds);
									    })();
										</script>
										<!-- 多说公共JS代码 end -->
										
  
    <article id="post-2014-05-18-FFI1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/05/18/2014-05-18-FFI1/" class="article-date">
  	<time datetime="2014-05-17T16:00:00.000Z" itemprop="datePublished">2014-05-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/18/2014-05-18-FFI1/">Real My Haskell (2)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Haskell_u4F7F_u7528_u5916_u90E8C_u51FD_u6570__281_29"><a href="#Haskell_u4F7F_u7528_u5916_u90E8C_u51FD_u6570__281_29" class="headerlink" title="Haskell使用外部C函数 (1)"></a>Haskell使用外部C函数 (1)</h2><p>  虽然C语言的编程方式和我的思考方式有着很多冲突，但是毕竟人家是很流行的语言，很多库都是在C/C++下实现的，<br>要想用Haskell做日常的各种事情，少不了这些库的帮助，但是重新写这些库既浪费时间又效率低下，<br>所以许许多多Haskell爱好者们开发出了FFI这个东西，使得Haskell能够和其他语言混合编程（调用其他语言的接口）。</p>
<p>由于目前C++的FFI不够完善，所以我们还是讲讲如何使用外部的C库。<br>用Haskell自然的思维方式编程，结合C语言各种强大的工具库，还有什么事情做不了呢？</p>
<p>事实上，在Haskell中使用C语言写成的函数非常简单,<br>在Haskell代码中加入这样一行：</p>
<pre><code>foreign import ccall &quot;m.h f&quot; c_f :: CDouble -&gt; CDouble
</code></pre><p>就可以从名为”m.h”的头文件中导入一个函数f</p>
<pre><code>double f(double _)
</code></pre><p>并且我们把这个函数重命名为c_f,它具有类型CDouble -&gt; CDouble<br>CDouble是Haskell中对应C中double的类型，Haskell与C之间许多类型都作了这样的处理。</p>
<p>事实上，如果对应C函数使用的类型在Haskell中已经有对应的定义，那么在Haskell中使用C函数会非常简单，<br>否则的话，需要自己定义对应的数据类型，不过我们有工具hcs2hs。</p>
<p>因此，接下来我们分两种情形考察如何在Haskell中使用外部的C函数。</p>
<p>首先我们要使用的C函数声明如下（”m.h”）：</p>
<pre><code>double f(double x);
double pf(double *x);

double af(double *x,int N);

typedef struct
{
int a;
int b; 
int c;
} mystruct;

int sum(mystruct *ms);
</code></pre><p>定义为（”m.c”）:</p>
<pre><code>double f(double x)
{
double y = x*x+2*x+1;
return y;
}

double pf(double *x)
{
return *x + 1;
}
#include &quot;m.h&quot;
double af(double *x, int N)
{
int i = 0;
double sum = 0.0;
for(i = 0 ;i &lt; N; i++)
{
sum += x[i];
}
return sum;
}

int sum(mystruct * ms)
{
return ms-&gt;a+ms-&gt;b+ms-&gt;c;
}
</code></pre><h3 id="u7B80_u5355_u7C7B_u578B"><a href="#u7B80_u5355_u7C7B_u578B" class="headerlink" title="简单类型"></a>简单类型</h3><p>首先我们不管结构体<strong>mystruct</strong>和函数<strong>sum</strong>,因为这些是需要自己处理的类型，</p>
<p>首先是用<strong>foreign import ccall</strong>导入这些函数并重命名，<br><strong>Ptr</strong>是C指针类型在Haskell中的对应，</p>
<pre><code>foreign import ccall unsafe &quot;m.h f&quot; c_f :: CDouble -&gt; CDouble
foreign import ccall unsafe &quot;m.h pf&quot; c_pf :: Ptr CDouble -&gt; CDouble
foreign import ccall unsafe &quot;m.h af&quot; c_af :: Ptr CDouble -&gt; CInt -&gt; CDouble
</code></pre><p>之后要做“本土化”工作，即写一个Haskell函数能够接受Haskell的数据类型并且调用这些外部函数计算得到结果。</p>
<p>需要注意的是，<br><strong>alloca</strong>和<strong>allocaArray</strong>这两个函数在局部范围内生成指针类型（用后即毁），<br><strong>poke</strong>函数能够将数据装入指针<strong>Ptr</strong>。</p>
<pre><code>fastf :: Double -&gt; IO Double
fastf x = return $ realToFrac (c_f (realToFrac x))    

-- passing pointers to C function
fastpf :: Double -&gt; IO Double
fastpf x = alloca $ \ptr -&gt; do 
poke ptr $ realToFrac x        -- set memory of ptr to x
return $ realToFrac $ c_pf ptr

-- passing arrays
fastaf :: [Double] -&gt; IO Double
fastaf x = allocaArray (length x) $ \ptr -&gt; do
pokeArray ptr $ map realToFrac x
return $ realToFrac $ c_af ptr $ fromIntegral (length x)
</code></pre><p>最后在main中使用就行了，全部代码综合在一起如下：</p>
<pre><code>{-# LANGUAGE ForeignFunctionInterface #-}
import Foreign
import Foreign.C.Types
import Foreign.Ptr

foreign import ccall unsafe &quot;m.h f&quot; c_f :: CDouble -&gt; CDouble
foreign import ccall unsafe &quot;m.h pf&quot; c_pf :: Ptr CDouble -&gt; CDouble
foreign import ccall unsafe &quot;m.h af&quot; c_af :: Ptr CDouble -&gt; CInt -&gt; CDouble


fastf :: Double -&gt; IO Double
fastf x = return $ realToFrac (c_f (realToFrac x))    

-- passing pointers to C function
fastpf :: Double -&gt; IO Double
fastpf x = alloca $ \ptr -&gt; do 
poke ptr $ realToFrac x        -- set memory of ptr to x
return $ realToFrac $ c_pf ptr

-- passing arrays
fastaf :: [Double] -&gt; IO Double
fastaf x = allocaArray (length x) $ \ptr -&gt; do
pokeArray ptr $ map realToFrac x
return $ realToFrac $ c_af ptr $ fromIntegral (length x)

main = do
x &lt;- fastf 12.0
y &lt;- fastpf 10.0
z &lt;- fastaf [1..10]
print x
print y
print z
</code></pre><p>最后</p>
<pre><code>gcc -c m.c
ghc m.o *.hs
</code></pre><p>就可以完成编译了。</p>
<h3 id="u7ED3_u6784_u4F53"><a href="#u7ED3_u6784_u4F53" class="headerlink" title="结构体"></a>结构体</h3><p>要处理结构体，就得使用hcs2hs这个工具，首先，<br>和之前一样，加入</p>
<pre><code>foreign import ccall unsafe &quot;m.h sum&quot; c_sum :: StructPtr -&gt; CInt 
</code></pre><p>再自己定义Haskell中对应mystruct的类型及其指针</p>
<pre><code>data Struct = Struct {a :: Int, b::Int ,c::Int}
type StructPtr = Ptr Struct
</code></pre><p>接下来，在使用这个数据类型<strong>Struct</strong>之前，<br>我们必须定义对应的<strong>poke</strong>之类的函数，把它作为<strong>Storable</strong>的类型类实例化：</p>
<pre><code>#include &quot;m.h&quot;
#let alignment t = &quot;%lu&quot;, (unsigned long)offsetof(struct {char x__; t (y__); }, y__)
instance Storable Struct where
sizeOf _ = (#size mystruct) 
alignment _ = #{alignment mystruct} 
peek ptr = do
a&apos; &lt;- (#peek mystruct,a) ptr
b&apos; &lt;- (#peek mystruct,b) ptr
c&apos; &lt;- (#peek mystruct,c) ptr
return Struct {a = a&apos;,b = b&apos;,c = c&apos;}
poke ptr (Struct a&apos; b&apos; c&apos;) = do
(#poke mystruct, a) ptr a&apos;
(#poke mystruct, b) ptr b&apos;
(#poke mystruct, c) ptr c&apos;
</code></pre><p>注意到上面的代码中有很多<strong>#xx</strong>的内容，这是hcs2hs的宏，我们不要管，只要知道这么用就行了，<br>当然想知道去查doc就行了。<br>还有</p>
<pre><code>#include &quot;m.h&quot;
</code></pre><p>显然是C代码，因此这个文件不能直接用ghc处理，<br>必须先用<strong>hcs2hs</strong>处理得到一个<strong>.hs</strong>文件，<br>之后才能和之前一样编译。</p>
<p>当然我们得先把整个代码补全：</p>
<pre><code>{-# LANGUAGE ForeignFunctionInterface #-}
import Foreign
import Foreign.C.Types
import Foreign.Ptr

foreign import ccall unsafe &quot;m.h f&quot; c_f :: CDouble -&gt; CDouble
foreign import ccall unsafe &quot;m.h pf&quot; c_pf :: Ptr CDouble -&gt; CDouble
foreign import ccall unsafe &quot;m.h af&quot; c_af :: Ptr CDouble -&gt; CInt -&gt; CDouble
foreign import ccall unsafe &quot;m.h sum&quot; c_sum :: StructPtr -&gt; CInt 

fastf :: Double -&gt; Double
fastf x = realToFrac (c_f (realToFrac x))    

-- passing pointers to C function
fastpf :: Double -&gt; IO Double
fastpf x = alloca $ \ptr -&gt; do 
poke ptr $ realToFrac x        -- set memory of ptr to x
return $ realToFrac $ c_pf ptr

-- passing arrays
fastaf :: [Double] -&gt; IO Double
fastaf x = allocaArray (length x) $ \ptr -&gt; do
pokeArray ptr $ map realToFrac x
return $ realToFrac $ c_af ptr $ fromIntegral (length x)

-- how about structs

data Struct = Struct {a :: Int, b::Int ,c::Int}
type StructPtr = Ptr Struct

-- We need to deal with the struct ourselves
-- make it an instance of Storable so peek and poke can be defined
-- but it is too trouble to do by hand 
-- so we can only use hsc2hs to deal with C and haskell mixes.
-- (The preprocess)
-- #xx are macros that are used by hsc2hs
#include &quot;m.h&quot;
#let alignment t = &quot;%lu&quot;, (unsigned long)offsetof(struct {char x__; t (y__); }, y__)
instance Storable Struct where
sizeOf _ = (#size mystruct) 
alignment _ = #{alignment mystruct} 
peek ptr = do
a&apos; &lt;- (#peek mystruct,a) ptr
b&apos; &lt;- (#peek mystruct,b) ptr
c&apos; &lt;- (#peek mystruct,c) ptr
return Struct {a = a&apos;,b = b&apos;,c = c&apos;}
poke ptr (Struct a&apos; b&apos; c&apos;) = do
(#poke mystruct, a) ptr a&apos;
(#poke mystruct, b) ptr b&apos;
(#poke mystruct, c) ptr c&apos;

fastsum :: Struct -&gt; IO Int
fastsum x = alloca $ \ptr -&gt; do 
poke ptr x        -- set memory of ptr to x
return $ fromIntegral $ c_sum ptr

main = do
x &lt;- fastf 12.0
y &lt;- fastpf 10.0
z &lt;- fastaf [1..10]
w &lt;- fastsum $ Struct {a=1,b=2,c=3}
print x
print y    
print z
print w
</code></pre><h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>以上的内容，涵盖了基本的Haskell的外部C函数接口，<br>基于这些东西，我们可以将C的库转化为Haskell的，当然如果你不想去写package，<br>也可以在你的实际中按需转化。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Haskell/">Haskell</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









<!-- 多说评论框 start -->
     <div class="ds-thread" data-thread-key="2014/05/18/2014-05-18-FFI1/" data-title="Real My Haskell (2)" data-url="http://yoursite.com/2014/05/18/2014-05-18-FFI1/"></div>
     <!-- 多说评论框 end -->
     <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
     <script type="text/javascript">
     var duoshuoQuery = {short_name:"hyxue-zeros"};
     	 (function() {
			var ds = document.createElement('script');
			       ds.type = 'text/javascript';ds.async = true;
			       	       	 ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					 	  ds.charset = 'UTF-8';
						  	       (document.getElementsByTagName('head')[0]
									 || document.getElementsByTagName('body')[0]).appendChild(ds);
									    })();
										</script>
										<!-- 多说公共JS代码 end -->
										
  
    <article id="post-2014-05-11-autodiff" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/05/11/2014-05-11-autodiff/" class="article-date">
  	<time datetime="2014-05-11T06:20:58.000Z" itemprop="datePublished">2014-05-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/11/2014-05-11-autodiff/">Dual Number &amp; Automatic Differentiation</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这些天发现一个很好玩的东西——dual number，二元数。同时还发现了许多新大陆——非标准分析和SDG（综合微分几何）……决定先记录下来。</p>
<p>二元数看起来它和复数差不多，都是人为创造的数系，但是这种数只能形成环的结构，无法成为数域，因此它无法像实数复数那样拥有强大的力量，并且成为分析的基础。不过这种数有着一个非常奇妙的用处，也正是这个用处把我吸引了过来，那就是它可以用来计算函数在某一点处的导数。</p>
<p>二元数，不同于实数之处在于其引入了一个幂零（nilpotent）元$\varepsilon$,这个元素就像虚数单位一样有着新的特性，$\varepsilon^{2}=0$，任意一个二元数可以表示为$a+b\varepsilon$,$a,b\in\mathbb{R}$。于是在这性质之上，可以得到一系列二元数的运算法则：</p>
<ol>
<li><p>加法： $$(a+a’\varepsilon)+(b+b’\varepsilon)=((a+b)+(a’+b’)\varepsilon)$$</p>
</li>
<li><p>减法： $$(a+a’\varepsilon)-(b+b’\varepsilon)=((a-b)+(a’-b’)\varepsilon)$$</p>
</li>
<li><p>乘法： $$(a+a’\varepsilon)\cdot (b+b’\varepsilon)=a\cdot b+(ab’+a’b)\varepsilon$$</p>
</li>
</ol>
<p>事实上，我们可以认为<br>$$<br>\varepsilon=<br>\begin{pmatrix}<br>0 &amp; 1 \<br>0 &amp; 0<br>\end{pmatrix}<br>$$</p>
<p>于是所有的运算法则都可以通过矩阵计算得到。</p>
<p>除法可以这样推导：</p>
<p>$$<br>\begin{aligned}<br>\frac{a+b\varepsilon}{c+d\varepsilon} &amp; =\frac{(a+b\varepsilon)(c-d\varepsilon)}{c^{2}}\<br> &amp; =\frac{a}{c}+\frac{bc-ad}{c^{2}}\varepsilon<br>\end{aligned}<br>$$</p>
<p>在二元数环上，我们可以定义各种初等函数运算，这些运算都可以通过二元数的基本定义得到，比如：</p>
<ul>
<li><p>$$\sin(a+b\varepsilon)=\sin(a)+b\cdot \cos(a)\varepsilon$$</p>
</li>
<li><p>$$\cos(a+b\varepsilon)=\cos(a)-b\cdot \sin(a)\varepsilon$$</p>
</li>
<li><p>$$\exp(a+b\varepsilon)=\exp(a)+b\cdot \exp(a)\varepsilon$$</p>
</li>
<li><p>$$\log(a+b\varepsilon)=\log(a)+(b/a)\varepsilon)$$</p>
</li>
</ul>
<p>其他初等函数的推导大同小异。</p>
<p>令$e=\varepsilon$，则对于任意可微的函数$f(x)$，它在$x=x_{0}$处的导数和它在二元数上的函数值相关，</p>
<p>即</p>
<p>$$f( x_{0} +e )=f(x_{0})+f’(x_{0})e$$</p>
<p>这个性质使得我们能够将求导直接变为求值，而无需先对目标函数进行符号求导，也避免使用不精确的数值导数来替代真正的导数值。</p>
<p>比如$$f(x)=x\cdot sin(x)\cdot exp(x+1)$$，</p>
<p>考虑$$x=1$$，</p>
<span>$$\begin{aligned}
f(1+e) &amp; =(1+e)\cdot \sin(1+e)\cdot \exp(2+e)\\
 &amp; =(1+\varepsilon)\cdot \sin(1+\varepsilon)\cdot \exp(2+\varepsilon)\\
 &amp; =(1+\varepsilon)\cdot (\sin(1)+\cos(1)\varepsilon)\cdot (\exp(2)+\exp(2)\varepsilon)
 \end{aligned}$$</span><!-- Has MathJax -->
<p>$$ =(\sin(1)+(\sin(1)+\cos(1))\varepsilon)\cdot (\exp(2)+\exp(2)\varepsilon)$$<br>$$ =(\sin(1)\cdot \exp(2)+(\sin(1)\cdot \exp(2)+(\sin(1)+\cos(1))\cdot \exp(2)\varepsilon)$$<br>$$  \thickapprox6.217676312367968+16.42767667317721\varepsilon$$</p>
<p>$$<br>f(1) \approx 6.217676312367968$$<br>$$f’(1) \approx 16.42767667317721$$</p>
<p>这就是所谓的自动微分（auto differentiation），我们可以写一个程序来自动计算，这正是自动微分的用途所在。相比于符号微分之后再求值，它可以减少计算量；相对于各种数值微分，又是精确的（对于计算机而言）。<br>我们这就写个程序来自动计算，实践证明这种东西（类似数学定义的东西）用Haskell写最为方便了：</p>
<pre><code>data Dual a = D a a deriving (Show, Eq)

instance Num a =&gt; Num (Dual a) where   
  fromInteger i = D (fromInteger i) 0   
  (D a a&apos;) + (D b b&apos;) = D (a+b) (a&apos;+b&apos;)   
  (D a a&apos;) - (D b b&apos;) = D (a-b) (a&apos;-b&apos;)   
  (D a a&apos;) * (D b b&apos;) = D (a*b) (a&apos;*b+a*b&apos;)   
  abs (D a a&apos;) = D (abs a) (a&apos; * (signum a))    

instance Fractional a =&gt; Fractional (Dual a) where   
  fromRational a = D (fromRational a) 0   
  (D a a&apos;) / (D b b&apos;) = D (a/b) ((a&apos;*b-a*b&apos;)/b/b)  

instance Floating a =&gt; Floating (Dual a) where   
  sin (D u u&apos;) = D (sin u) (u&apos; * (cos u))   
  cos (D u u&apos;) = D (cos u) (-u&apos; * (sin u))   
  exp (D u u&apos;) = D (exp u) (u&apos; * (exp u))   
  log (D u u&apos;) = D (log u) (u&apos;/u)   
  pi = D pi 0    
  e = D 0 1
</code></pre><p>我们先定义二元数及其计算规则，接下来定义函数：</p>
<pre><code>f :: Floating a =&gt; a -&gt; a f x = x * sin(x) * exp (x+1) 
</code></pre><p>计算：</p>
<pre><code>&gt;f(1+e)
D 6.217676312367968 16.427676673177206
</code></pre><p>至于多变量函数，可以由单变量很简单的进行推广。</p>
<p>dual number似乎和非标准分析学中的无穷小量（infinitesimal)有关，事实上可以将$$\varepsilon$$看成是无穷小单位的一阶近似。非标准分析学将无穷量正式地引入了数域，将实数集扩充为超实数集，并且确保了逻辑上的严密性，这是一个很年轻的数学分支，不过似乎也很默默无闻。无穷小量早在微积分创立之初出现，随后由于一系列的逻辑问题，被宣判死亡，直到上个世纪下半叶，被某些数学家复活了，出现了非标准分析这一分支，大多数数学家，科学家，学生都是在传统分析的框架下长大的，也许很多人从未听说过这一领域，就如同我一样，刚刚知道这个东西，传统的概念已经根深蒂固，成为一种常识和习惯，往往就再也难以改变，至于非标准分析能否被广泛接受，就留给时间去考虑吧。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/old/">old</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









<!-- 多说评论框 start -->
     <div class="ds-thread" data-thread-key="2014/05/11/2014-05-11-autodiff/" data-title="Dual Number &amp; Automatic Differentiation" data-url="http://yoursite.com/2014/05/11/2014-05-11-autodiff/"></div>
     <!-- 多说评论框 end -->
     <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
     <script type="text/javascript">
     var duoshuoQuery = {short_name:"hyxue-zeros"};
     	 (function() {
			var ds = document.createElement('script');
			       ds.type = 'text/javascript';ds.async = true;
			       	       	 ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					 	  ds.charset = 'UTF-8';
						  	       (document.getElementsByTagName('head')[0]
									 || document.getElementsByTagName('body')[0]).appendChild(ds);
									    })();
										</script>
										<!-- 多说公共JS代码 end -->
										
  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-right">
    		&copy; 2016 xuehy
    	</div>
     
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>



<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-51165937-2', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>